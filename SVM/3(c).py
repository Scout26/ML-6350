# -*- coding: utf-8 -*-
"""3(c)

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1GF-0z7klINPIv6zZrelPyno5ksY_QGQV
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from scipy.optimize import minimize
from scipy.spatial.distance import cdist

# Load training and testing datasets into the dataframe
train_data = pd.read_csv('train.csv', header=None)
test_data = pd.read_csv('test.csv', header=None)

# Separate features (X) and labels (y) for training and testing datasets
X_train = train_data.iloc[:, :-1].values
y_train = train_data.iloc[:, -1].values
X_test = test_data.iloc[:, :-1].values
y_test = test_data.iloc[:, -1].values

# Change labels from {0, 1} to {-1, 1} for SVM compatibility
y_train = np.where(y_train == 0, -1, 1)
y_test = np.where(y_test == 0, -1, 1)

# Set values for C and gamma
C_list = [100 / 873, 500 / 873, 700 / 873]
gamma_list = [0.01, 0.1, 0.5, 1, 5, 100]

# Function to compute the Gaussian kernel matrix
def compute_gaussian_kernel(X1, X2, gamma_value):
    # This will help to calculate the squared distances between points
    squared_distances = cdist(X1, X2, 'sqeuclidean')
    # Applying the Gaussian kernel formula
    return np.exp(-squared_distances / gamma_value)

# Function to compute the objective function for dual SVM
def dual_svm_objective(alpha, kernel_matrix, labels):
    # Calculate the objective value
    return 0.5 * alpha @ (labels * labels.T * kernel_matrix) @ alpha - np.sum(alpha)

# Constraint to ensure sum(alpha_i * y_i) = 0
def constraint_equality(alpha, labels):
    return np.dot(alpha, labels)

# Dictionary to store support vector information
support_vectors_data = {}

# Loop through all gamma values
for gamma in gamma_list:
    # Compute the kernel matrix for the current gamma
    kernel_train = compute_gaussian_kernel(X_train, X_train, gamma)

    # Loop through all C values
    for C in C_list:
        num_samples = X_train.shape[0]

        # Initial alpha values set to zero
        alpha_initial = np.zeros(num_samples)

        # Constraints: alpha values are between 0 and C, and the equality constraint
        constraints = ({'type': 'eq', 'fun': constraint_equality, 'args': (y_train,)})
        bounds = [(0, C) for _ in range(num_samples)]

        # Solve the optimization problem using SLSQP
        solution = minimize(dual_svm_objective, alpha_initial, args=(kernel_train, y_train),
                            method='SLSQP', bounds=bounds, constraints=constraints)
        optimal_alpha = solution.x

        # Identify support vectors: alpha values that lie between 0 and C
        support_indices = np.where((optimal_alpha > 1e-5) & (optimal_alpha < C - 1e-5))[0]
        support_vectors_data[(C, gamma)] = support_indices

        # Compute the bias term (b) using support vectors
        if len(support_indices) > 0:
            bias = np.mean(y_train[support_indices] - np.dot(kernel_train[support_indices], (optimal_alpha * y_train)))
        else:
            bias = 0

        # Print the bias term
        print(f"For value of C = {C:.4f}, Value of Gamma = {gamma}: Value of Bias = {bias:.4f}")

        # Compute training and testing predictions
        train_predictions = np.sign(np.dot(kernel_train, (optimal_alpha * y_train)) + bias)
        train_error = np.mean(train_predictions != y_train)

        kernel_test = compute_gaussian_kernel(X_test, X_train, gamma)
        test_predictions = np.sign(np.dot(kernel_test, (optimal_alpha * y_train)) + bias)
        test_error = np.mean(test_predictions != y_test)

        # Print training and testing error rates
        print(f"For value of C = {C:.4f}, Value of Gamma = {gamma}: Training Error = {train_error:.4f}, Test Error = {test_error:.4f}")

        # Print the number of support vectors
        print(f"For value of C = {C:.4f}, Value of Gamma = {gamma}: Count of Support Vectors = {len(support_indices)}")

# Compare when C is 500/873
target_C = 500 / 873
overlap_counts = []
for idx in range(len(gamma_list) - 1):
    gamma_current = gamma_list[idx]
    gamma_next = gamma_list[idx + 1]
    sv_current = set(support_vectors_data[(target_C, gamma_current)])
    sv_next = set(support_vectors_data[(target_C, gamma_next)])
    overlap = len(sv_current.intersection(sv_next))
    overlap_counts.append((gamma_current, gamma_next, overlap))
    print(f"For value of C = {target_C:.4f}, Overlap between Gamma = {gamma_current} and Gamma = {gamma_next}: {overlap}")

